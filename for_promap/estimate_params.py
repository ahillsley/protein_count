import numpy as npimport skimage.io, scipyimport pandas as pdfrom fluorescence_model import EmissionParamsfrom trace_model import TraceModelfrom intensity_trace import IntensityTraceimport matplotlib.pyplot as pltimport seaborn as snsfrom pomegranate import GeneralMixtureModel, LogNormalDistributionfrom scipy.optimize import curve_fit''' Functions to pre-process the images and extract traces'''def read_image(file_path):    img = skimage.io.imread(file_path)    np_img = np.array(img)    np_img = np.moveaxis(np_img, 0,2)        return np_imgdef clean_spots(spots, img):    spots = np.vstack((np.asarray(spots['y'], ),                        np.asarray(spots['x']))).astype('int')        bad_spots = np.concatenate((np.where(spots <= 5)[1], np.where(spots >= img.shape[0]-5)[1]))    clean_spots = np.concatenate((np.expand_dims(np.delete(spots[0,:], bad_spots),1),                                   np.expand_dims(np.delete(spots[1,:], bad_spots),1)),                                 axis = 1)    return clean_spotsdef pixel_t_trace(img, y ,x, pxl_size):    if pxl_size == 0:        crop = img[y,x,:]    else:        crop = img[(y-pxl_size):(y+pxl_size), (x-pxl_size):(x+pxl_size),:]        crop = np.max(crop, axis=0)        crop = np.max(crop, axis=0)        return crop    def background_simple(img, trace, x, y, tile=7, scaled=False,                       background_mu=1, scale=1):    baseline = np.zeros((len(trace)))        # keep bounding box within image dimensions    lower_y = (y - tile) if (y-tile)> 0 else 0    upper_y = (y + tile) if (y+tile)<img.shape[0] else img.shape[0]    lower_x = (x - tile) if (x-tile)> 0 else 0    upper_x = (x + tile) if (x+tile)<img.shape[1] else img.shape[1]        for i in range(len(trace)):        baseline[i] = np.mean(img[lower_y:upper_y,lower_x:upper_x,i])            if scaled is True:        baseline = (baseline*scale) - (background_mu * scale)        background_subtracted = trace - baseline + np.mean(baseline)    else:           background_subtracted = trace - baseline            if np.min(background_subtracted) <= 0:        background_subtracted += abs(np.min(background_subtracted)) +1e-6    return background_subtracted, baselinedef extract_traces(img, spots):    c_spots = clean_spots(spots, img)    traces = np.zeros((len(c_spots), img.shape[2]))    for i in range(len(traces)):        traces[i,:] = pixel_t_trace(img, c_spots[i,0], c_spots[i,1], 3 )        return traces    '''functions to determine initial guesses of model parameters'''def joint_line_search_fit(traces,                          y,                          points=100,                          p_on_max=0.5,                          p_off_max=0.5,                          eps=1e-3,                          max_iterations=10):        p_ons = np.linspace(1e-6, p_on_max, points)    p_offs = np.linspace(1e-6, p_off_max, points)        # initializations    i = 0    trace_model = TraceModel(EmissionParams(), 0.1, traces.shape[1])    prev_prob = None    trace_model.p_off = np.mean(p_offs)        while i <= max_iterations:        best_p_on_prob = None        best_p_on = None                for p_on in p_ons:            trace_model.p_on = p_on                        log_prob = 0            for trace in traces:                log_prob += trace_model.p_trace_given_y(trace, y)                            if best_p_on_prob is None or log_prob > best_p_on_prob:                best_p_on_prob = log_prob                best_p_on = p_on                # re-initialize        trace_model.p_on = best_p_on        best_p_off_prob = None        best_p_off = None            for p_off in p_offs:            trace_model.p_off = p_off                        log_prob = 0            for trace in traces:                log_prob += trace_model.p_trace_given_y(trace, y)                            if best_p_off_prob is None or log_prob > best_p_off_prob:                best_p_off_prob = log_prob                best_p_off = p_off                        trace_model.p_off = best_p_off        i += 1                if prev_prob is not None:            delta_prob = best_p_off_prob - prev_prob            assert(delta_prob >= 0)            if delta_prob <= eps:                break        prev_prob = best_p_off_prob            return best_p_on, best_p_off        '''    trace_model = TraceModel(ModelParams(), 0.1, len(trace))    trace_model._line_search_params(trace, 1, points=10, p_on_max=0.1)    '''    returndef joint_viterbi_fit(traces):    all_bright_times = np.zeros((1))    all_dark_times = np.zeros((1))    for i, trace in enumerate(traces):        trace_model = TraceModel(EmissionParams(), 0.1, len(trace))        trace_model.set_params(0.002, 0.2)        p_initial, transition_m = trace_model._markov_trace(1)        states, delta, sci = trace_model._scale_viterbi(trace, 1, len(trace),                                             transition_m, p_initial)        # state change information to estimate bright and dark times        state_change = np.where(states[:-1] != states[1:])[0]        bright_times = np.zeros((1))        dark_times = np.zeros((1))        on_off = np.split(states, state_change+1)        for i in range(len(on_off)):            event_length = len(on_off[i])            if np.mean(on_off[i]) == 0:                dark_times = np.append(dark_times, event_length)            else:                bright_times = np.append(bright_times, event_length)                all_bright_times = np.append(all_bright_times, bright_times)        all_dark_times = np.append(all_dark_times, dark_times)            dark_cdf_x = np.sort(all_dark_times[all_dark_times != 0])    dark_cdf_y = np.arange(len(dark_cdf_x))/len(dark_cdf_x)    lam_dark, pcov_d = curve_fit(trace_model._exp_cdf, dark_cdf_x, dark_cdf_y)    bright_cdf_x = np.sort(all_bright_times[all_bright_times != 0])    bright_cdf_y = np.arange(len(bright_cdf_x))/len(bright_cdf_x)    lam_bright, pcov_d = curve_fit(trace_model._exp_cdf,                                   bright_cdf_x, bright_cdf_y)    p_on_estimate = lam_dark * np.exp(-lam_dark * trace_model.step_time)    p_off_estimate = lam_bright * np.exp(-lam_bright * trace_model.step_time)            return p_on_estimate, p_off_estimateif __name__ == "__main__":        image_file_path = '../../Images/0525_5nM_1.tif'    spots_file_path = '../../Images/0525_5_nM_1_spots.csv'    img = read_image(image_file_path)    spots = pd.read_csv(spots_file_path)    spot_list = clean_spots(spots, img)    traces = extract_traces(img, spots)    scaled_traces = np.ones_like(traces)    scales = np.ones((traces.shape[0]))        #p_values = process_image(img, spot_list)            for i, trace in enumerate(traces[230:240,:]):       norm_trace = normalize_trace(trace)       scaled_traces[i,:] = background_simple(img, norm_trace[0],                                               spot_list[i, 1],                                               spot_list[i, 0],                                              tile=7, scaled=True,                                              background_mu =norm_trace[2],                                              scale = norm_trace[1])[0]    